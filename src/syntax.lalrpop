use crate::{
  arena::Arena,
  ast::{Expr, Stmt, Binop, Unop, Prog},
  runtime::strton::{strtoi,strtod},
  lexer::{self, Tok},
};

// TODO: function calls. Hopefully we do not need to modify the lexer for that, but we may...
// TODO: rationalize handling of semicolons and newlines. We are probably missing some things here,
//       but that will become clearer over time.
grammar<'a, 'outer>(arena: &'a Arena<'outer>, buf: &mut Vec<u8>);

pub Prog: Prog<'a,'a,&'a str> = {
    NL <begin:Begin?> <pats:PatAction*> <sa:Expr?> <end:End?> =>
        Prog {
            begin,
            end,
            pats: {
                let mut pats = pats;
                if let Some(sa) = sa {
                    pats.push((Some(sa), None));
                }
                pats
            }
        }
}

Begin: &'a Stmt<'a,'a,&'a str> = {
    "BEGIN" <Block> => <>
}

End: &'a Stmt<'a,'a,&'a str> = {
    "END" <Block> => <>
}

PatAction: (Option<&'a Expr<'a,'a,&'a str>>, Option<&'a Stmt<'a,'a,&'a str>>) = {
    <p:Expr?> <b:Block> NL => (p, Some(b))
}

pub(crate) Stmt: &'a Stmt<'a,'a,&'a str> = {
    "if" "(" <cond:Expr> ")" NL <s1:BaseStmt> "else" NL <s2:Stmt> =>
	arena.alloc_v(Stmt::If(cond, s1, Some(s2))),
    "if" "(" <cond:Expr> ")" NL <s1:BaseStmt> => arena.alloc_v(Stmt::If(cond, s1, None)),
    "do" NL <body:BaseStmt> "while" "(" <cond:Expr> ")" => arena.alloc_v(Stmt::DoWhile(cond, body)),
    "while" NL "(" <cond:Expr> ")" <body:BaseStmt> => arena.alloc_v(Stmt::While(cond, body)),
    "for" "(" <init: ExprNoIn?> ";" <cond:Expr?> ";" <update:Expr?> ")" NL <body:BaseStmt> =>
        arena.alloc_v(Stmt::For(
                init.map(|x| arena.alloc_v(Stmt::Expr(x))),
                cond,
                update.map(|x| arena.alloc_v(Stmt::Expr(x))),
                body
        )),
    "for" "(" <id:"IDENT"> "in" <arr:Expr> ")" NL <body: BaseStmt> =>
        arena.alloc_v(Stmt::ForEach(id, arr, body)),
    BaseStmt,
}

Redirect: (&'a Expr<'a, 'a, &'a str>, bool) = {
    ">" <BaseTerm> => (<>, false),
    ">>" <BaseTerm> => (<>, true),
}


BaseStmt: &'a Stmt<'a,'a,&'a str> = {
    <e: Expr> => arena.alloc_v(Stmt::Expr(e)),
    "print" <pa:PrintArgs?> <re:Redirect?> => arena.alloc_v(Stmt::Print(pa.unwrap_or(Vec::new()), re)),
    "break" => arena.alloc_v(Stmt::Break),
    "continue" => arena.alloc_v(Stmt::Continue),
    Block,
}

Block: &'a Stmt<'a,'a,&'a str> = {
    "{" NL "}" => arena.alloc_v(Stmt::Block(vec![])),
    "{" NL <Stmt> "}" => <>,
    "{" NL  <BlockInner> "}" => arena.alloc_v(Stmt::Block(<>)),
}

BlockInner: Vec<&'a Stmt<'a,'a,&'a str>> = {
    <v:(<Stmt> Sep)+> <e:Stmt?> => match e {
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
}

PrintArgs: Vec<&'a Expr<'a,'a,&'a str>> = {
    // To avoid ambiguities with expressions including ">" we jump down the precedence hierarchy
    // past the comparison operators.
    <PrecAdd> => vec![<>],
    <v:(<PrecAdd> ",")+> <e:PrecAdd?> => match e {
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
}

NL: () = "\n"*;

Sep: () = {
    SepBase+
}

SepBase: () = { ";", "\n" }

pub(crate) Expr: &'a Expr<'a,'a,&'a str> = {
    "getline" <into:BaseTerm?> <from:("<" <BaseTerm>)?> => arena.alloc_v(Expr::Getline{ into, from}),
    // TODO may need to disambiguate function calls at the lexer level.
    // <i:Ident> "(" <args:PrintArgs?> ")" => panic!("nyi"),
    PrecAsgn
};

PrecAsgn: &'a Expr<'a,'a,&'a str> = {
    <l: PrecIn> "=" <r: PrecAsgn> => arena.alloc_v(Expr::Assign(l, r)),
    <l: PrecIn> "+=" <r: PrecAsgn> => arena.alloc_v(Expr::AssignOp(l, Binop::Plus, r)),
    <l: PrecIn> "-=" <r: PrecAsgn> => arena.alloc_v(Expr::AssignOp(l, Binop::Minus, r)),
    <l: PrecIn> "*=" <r: PrecAsgn> => arena.alloc_v(Expr::AssignOp(l, Binop::Mult, r)),
    <l: PrecIn> "/=" <r: PrecAsgn> => arena.alloc_v(Expr::AssignOp(l, Binop::Div, r)),
    <l: PrecIn> "%=" <r: PrecAsgn> => arena.alloc_v(Expr::AssignOp(l, Binop::Mod, r)),
    PrecIn
}

// XXX Replicate the first two layers of the precedence hierarchy to skip "in" expressions to avoid
// ambiguity between beginning of for loop and foreach loop. This is a hack; we should find a way
// to tell LALRPOP the right thing here.
ExprNoIn: &'a Expr<'a,'a,&'a str> = {
    "getline" <into:BaseTerm?> <from:("<" <BaseTerm>)?> => arena.alloc_v(Expr::Getline{ into, from}),
    PrecAsgnNoIn
};

PrecAsgnNoIn: &'a Expr<'a,'a,&'a str> = {
    <l: PrecMatch> "=" <r: PrecAsgn> => arena.alloc_v(Expr::Assign(l, r)),
    <l: PrecMatch> "+=" <r: PrecAsgn> => arena.alloc_v(Expr::AssignOp(l, Binop::Plus, r)),
    <l: PrecMatch> "-=" <r: PrecAsgn> => arena.alloc_v(Expr::AssignOp(l, Binop::Minus, r)),
    <l: PrecMatch> "*=" <r: PrecAsgn> => arena.alloc_v(Expr::AssignOp(l, Binop::Mult, r)),
    <l: PrecMatch> "/=" <r: PrecAsgn> => arena.alloc_v(Expr::AssignOp(l, Binop::Div, r)),
    <l: PrecMatch> "%=" <r: PrecAsgn> => arena.alloc_v(Expr::AssignOp(l, Binop::Mod, r)),
    PrecMatch
}

PrecIn: &'a Expr<'a,'a,&'a str> = {
    <l: PrecMatch> "in" <r: PrecMatch> => panic!("we have not yet wired in `in`"),
    PrecMatch,
}

// This is where we would add ?: || &&
// see: https://www.gnu.org/software/gawk/manual/html_node/Precedence.html
//

PrecMatch: &'a Expr<'a,'a,&'a str> = {
    <l: PrecMatch> "~" <r: PrecCmp> => arena.alloc_v(Expr::Binop(Binop::Match, l, r)),
    <l: PrecMatch> "!~" <r: PrecCmp> => arena.alloc_v(Expr::Unop(
            Unop::Not,
            arena.alloc_v(Expr::Binop(Binop::Match, l, r)))),
    PrecCmp,
}

PrecCmp: &'a Expr<'a,'a,&'a str> = {
    <l: PrecAdd> "<" <r: PrecCmp> => arena.alloc_v(Expr::Binop(Binop::LT, l, r)),
    <l: PrecAdd> "<=" <r: PrecCmp> => arena.alloc_v(Expr::Binop(Binop::LTE, l, r)),
    <l: PrecAdd> ">" <r: PrecCmp> => arena.alloc_v(Expr::Binop(Binop::GT, l, r)),
    <l: PrecAdd> ">=" <r: PrecCmp> => arena.alloc_v(Expr::Binop(Binop::GTE, l, r)),
    <l: PrecAdd> "==" <r: PrecCmp> => arena.alloc_v(Expr::Binop(Binop::EQ, l, r)),
    PrecAdd
}

PrecAdd: &'a Expr<'a,'a,&'a str> = {
    <l: PrecAdd> "+" <r:PrecMul>  => arena.alloc_v(Expr::Binop(Binop::Plus, l, r)),
    <l: PrecAdd> "-" <r:PrecMul>  => arena.alloc_v(Expr::Binop(Binop::Minus, l, r)),
    PrecMul,
}

PrecMul: &'a Expr<'a,'a,&'a str> = {
    <l: PrecMul> "*" <r:PrecUnop> => arena.alloc_v(Expr::Binop(Binop::Mult, l, r)),
    <l: PrecMul> "/" <r:PrecUnop> => arena.alloc_v(Expr::Binop(Binop::Div, l, r)),
    <l: PrecMul> "%" <r:PrecUnop> => arena.alloc_v(Expr::Binop(Binop::Mod, l, r)),
    PrecUnop,
}

PrecUnop: &'a Expr<'a,'a,&'a str> = {
    "-" <e: PrecInc> => arena.alloc_v(Expr::Unop(Unop::Neg, e)),
    "+" <e: PrecInc> => arena.alloc_v(Expr::Unop(Unop::Pos, e)),
    "!" <e: PrecInc> => arena.alloc_v(Expr::Unop(Unop::Not, e)),
    PrecInc
}

PrecInc: &'a Expr<'a,'a,&'a str> = {
    <e:CatBaseTerm>"++" => arena.alloc_v(Expr::Inc { is_inc: true, is_post: true, x: e }),
    <e:CatBaseTerm>"--"=> arena.alloc_v(Expr::Inc { is_inc: false, is_post: true, x: e }),
    "++" <e:CatBaseTerm> => arena.alloc_v(Expr::Inc { is_inc: true, is_post: false, x: e }),
    "--" <e:CatBaseTerm> => arena.alloc_v(Expr::Inc { is_inc: false, is_post: false, x: e }),
    CatBaseTerm,
}

CatBaseTerm: &'a Expr<'a,'a, &'a str> = {
    <l: CatBaseTerm> <r: PrecFieldRef> => arena.alloc_v(Expr::Binop(Binop::Concat, l, r)),
    PrecFieldRef
}

PrecFieldRef: &'a Expr<'a,'a,&'a str> = {
    Col,
    BaseTerm
}

Col: &'a Expr<'a,'a,&'a str> = {
    "$" <e:BaseTerm> => arena.alloc_v(Expr::Unop(Unop::Column, e)),
}

Ident: &'a Expr<'a,'a,&'a str> = {
  "IDENT" => arena.alloc_v(Expr::Var(arena.alloc_str(<>))),
}

StrLit: &'a Expr<'a,'a,&'a str> = {
  "STRLIT" => arena.alloc_v(Expr::StrLit(lexer::parse_string_literal(<>, &arena, buf))),
}

Index: &'a Expr<'a,'a,&'a str> = {
  <arr:BaseTerm>"[" <e:BaseTerm> "]" => arena.alloc_v(Expr::Index(arr, e)),
}

BaseTerm: &'a Expr<'a,'a, &'a str> = {
  Ident,
  Index,
  StrLit,
  "INT" => arena.alloc_v(Expr::ILit(strtoi(<>))),
  "FLOAT" => arena.alloc_v(Expr::FLit(strtod(<>))),
  "PATLIT" => arena.alloc_v(Expr::PatLit(lexer::parse_regex_literal(<>, &arena, buf))),
  "(" <e:Expr> ")" => e,
}

extern {
  type Location = usize;
  type Error = lexer::Error;
  enum Tok<'a> {
      "INT" => Tok::ILit(<&'a str>),
      "FLOAT" => Tok::FLit(<&'a str>),
      "IDENT" => Tok::Ident(<&'a str>),
      "STRLIT" => Tok::StrLit(<&'a str>),
      "PATLIT" => Tok::PatLit(<&'a str>),
      "BEGIN" =>  Tok::Begin,
      "END" =>  Tok::End,
      "break" =>  Tok::Break,
      "continue" =>  Tok::Continue,
      "for" =>  Tok::For,
      "if" =>  Tok::If,
      "else" => Tok::Else,
      "print" =>  Tok::Print,
      "while" =>  Tok::While,
      "do" =>  Tok::Do,
      "{" =>  Tok::LBrace,
      "}" =>  Tok::RBrace,
      "[" =>  Tok::LBrack,
      "]" =>  Tok::RBrack,
      "(" =>  Tok::LParen,
      ")" =>  Tok::RParen,
      "getline" =>  Tok::Getline,
      "=" =>  Tok::Assign,
      "+" =>  Tok::Add,
      "+=" =>  Tok::AddAssign,
      "-" =>  Tok::Sub,
      "-=" =>  Tok::SubAssign,
      "*" =>  Tok::Mul,
      "*=" =>  Tok::MulAssign,
      "/" =>  Tok::Div,
      "/=" =>  Tok::DivAssign,
      "%" =>  Tok::Mod,
      "%=" =>  Tok::ModAssign,
      "~" =>  Tok::Match,
      "!~" =>  Tok::NotMatch,
      "==" =>  Tok::EQ,
      "<" =>  Tok::LT,
      "<=" =>  Tok::LTE,
      ">" =>  Tok::GT,
      "--" =>  Tok::Decr,
      "++" =>  Tok::Incr,
      ">=" =>  Tok::GTE,
      ">>" =>  Tok::Append,
      ";" =>  Tok::Semi,
      "$" => Tok::Dollar,
      "\n" =>  Tok::Newline,
      "," =>  Tok::Comma,
      "!" => Tok::Not,
      "in" => Tok::In,
  }
}
